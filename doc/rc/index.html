<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Thread-local reference-counted boxes (the `Rc<T>` type)."><meta name="keywords" content="rust, rustlang, rust-lang, rc"><title>rc - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings"></script><script src="../storage.js"></script><script src="../crates.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../rc/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><p class="location">Crate rc</p><div class="block version"><p>Version 0.1.1</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all rc's items</p></a><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#functions">Functions</a></li></ul></div><p class="location"></p><div id="sidebar-vars" data-name="rc" data-ty="mod" data-relpath="../"></div></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../brush.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="">rc</a><button id="copy-path" onclick="copy_path(this)">⎘</button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/rc/lib.rs.html#11-152" title="goto source code">[src]</a></span></h1><div class="docblock"><p>Thread-local reference-counted boxes (the <code>Rc&lt;T&gt;</code> type).</p>
<p>The <code>Rc&lt;T&gt;</code> type provides shared ownership of an immutable value.
Destruction is deterministic, and will occur as soon as the last owner is
gone. It is marked as non-sendable because it avoids the overhead of atomic
reference counting.</p>
<p>The <code>downgrade</code> method can be used to create a non-owning <code>Weak&lt;T&gt;</code> pointer
to the box. A <code>Weak&lt;T&gt;</code> pointer can be upgraded to an <code>Rc&lt;T&gt;</code> pointer, but
will return <code>None</code> if the value has already been dropped.</p>
<p>For example, a tree with parent pointers can be represented by putting the
nodes behind strong <code>Rc&lt;T&gt;</code> pointers, and then storing the parent pointers
as <code>Weak&lt;T&gt;</code> pointers.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p>Consider a scenario where a set of <code>Gadget</code>s are owned by a given <code>Owner</code>.
We want to have our <code>Gadget</code>s point to their <code>Owner</code>. We can’t do this with
unique ownership, because more than one gadget may belong to the same
<code>Owner</code>. <code>Rc&lt;T&gt;</code> allows us to share an <code>Owner</code> between multiple <code>Gadget</code>s,
and have the <code>Owner</code> remain allocated as long as any <code>Gadget</code> points at it.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">rc::Rc</span>;

<span class="kw">struct</span> <span class="ident">Owner</span> {
    <span class="ident">name</span>: <span class="ident">String</span>
    <span class="comment">// ...other fields</span>
}

<span class="kw">struct</span> <span class="ident">Gadget</span> {
    <span class="ident">id</span>: <span class="ident">i32</span>,
    <span class="ident">owner</span>: <span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Owner</span><span class="op">&gt;</span>
    <span class="comment">// ...other fields</span>
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="comment">// Create a reference counted Owner.</span>
    <span class="kw">let</span> <span class="ident">gadget_owner</span> : <span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Owner</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Rc::new</span>(
            <span class="ident">Owner</span> { <span class="ident">name</span>: <span class="ident">String::from</span>(<span class="string">&quot;Gadget Man&quot;</span>) }
    );

    <span class="comment">// Create Gadgets belonging to gadget_owner. To increment the reference</span>
    <span class="comment">// count we clone the `Rc&lt;T&gt;` object.</span>
    <span class="kw">let</span> <span class="ident">gadget1</span> <span class="op">=</span> <span class="ident">Gadget</span> { <span class="ident">id</span>: <span class="number">1</span>, <span class="ident">owner</span>: <span class="ident">gadget_owner</span>.<span class="ident">clone</span>() };
    <span class="kw">let</span> <span class="ident">gadget2</span> <span class="op">=</span> <span class="ident">Gadget</span> { <span class="ident">id</span>: <span class="number">2</span>, <span class="ident">owner</span>: <span class="ident">gadget_owner</span>.<span class="ident">clone</span>() };

    <span class="ident">drop</span>(<span class="ident">gadget_owner</span>);

    <span class="comment">// Despite dropping gadget_owner, we&#39;re still able to print out the name</span>
    <span class="comment">// of the Owner of the Gadgets. This is because we&#39;ve only dropped the</span>
    <span class="comment">// reference count object, not the Owner it wraps. As long as there are</span>
    <span class="comment">// other `Rc&lt;T&gt;` objects pointing at the same Owner, it will remain</span>
    <span class="comment">// allocated. Notice that the `Rc&lt;T&gt;` wrapper around Gadget.owner gets</span>
    <span class="comment">// automatically dereferenced for us.</span>
    <span class="macro">println!</span>(<span class="string">&quot;Gadget {} owned by {}&quot;</span>, <span class="ident">gadget1</span>.<span class="ident">id</span>, <span class="ident">gadget1</span>.<span class="ident">owner</span>.<span class="ident">name</span>);
    <span class="macro">println!</span>(<span class="string">&quot;Gadget {} owned by {}&quot;</span>, <span class="ident">gadget2</span>.<span class="ident">id</span>, <span class="ident">gadget2</span>.<span class="ident">owner</span>.<span class="ident">name</span>);

    <span class="comment">// At the end of the method, gadget1 and gadget2 get destroyed, and with</span>
    <span class="comment">// them the last counted references to our Owner. Gadget Man now gets</span>
    <span class="comment">// destroyed as well.</span>
}</pre></div>
<p>If our requirements change, and we also need to be able to traverse from
Owner → Gadget, we will run into problems: an <code>Rc&lt;T&gt;</code> pointer from Owner
→ Gadget introduces a cycle between the objects. This means that their
reference counts can never reach 0, and the objects will remain allocated: a
memory leak. In order to get around this, we can use <code>Weak&lt;T&gt;</code> pointers.
These pointers don’t contribute to the total count.</p>
<p>Rust actually makes it somewhat difficult to produce this loop in the first
place: in order to end up with two objects that point at each other, one of
them needs to be mutable. This is problematic because <code>Rc&lt;T&gt;</code> enforces
memory safety by only giving out shared references to the object it wraps,
and these don’t allow direct mutation. We need to wrap the part of the
object we wish to mutate in a <code>RefCell</code>, which provides <em>interior
mutability</em>: a method to achieve mutability through a shared reference.
<code>RefCell</code> enforces Rust’s borrowing rules at runtime.  Read the <code>Cell</code>
documentation for more details on interior mutability.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">rc::Rc</span>;
<span class="kw">use</span> <span class="ident">rc::Weak</span>;
<span class="kw">use</span> <span class="ident">std::cell::RefCell</span>;

<span class="kw">struct</span> <span class="ident">Owner</span> {
    <span class="ident">name</span>: <span class="ident">String</span>,
    <span class="ident">gadgets</span>: <span class="ident">RefCell</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Weak</span><span class="op">&lt;</span><span class="ident">Gadget</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span>
    <span class="comment">// ...other fields</span>
}

<span class="kw">struct</span> <span class="ident">Gadget</span> {
    <span class="ident">id</span>: <span class="ident">i32</span>,
    <span class="ident">owner</span>: <span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Owner</span><span class="op">&gt;</span>
    <span class="comment">// ...other fields</span>
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="comment">// Create a reference counted Owner. Note the fact that we&#39;ve put the</span>
    <span class="comment">// Owner&#39;s vector of Gadgets inside a RefCell so that we can mutate it</span>
    <span class="comment">// through a shared reference.</span>
    <span class="kw">let</span> <span class="ident">gadget_owner</span> : <span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Owner</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Rc::new</span>(
            <span class="ident">Owner</span> {
                <span class="ident">name</span>: <span class="string">&quot;Gadget Man&quot;</span>.<span class="ident">to_string</span>(),
                <span class="ident">gadgets</span>: <span class="ident">RefCell::new</span>(<span class="ident">Vec::new</span>())
            }
    );

    <span class="comment">// Create Gadgets belonging to gadget_owner as before.</span>
    <span class="kw">let</span> <span class="ident">gadget1</span> <span class="op">=</span> <span class="ident">Rc::new</span>(<span class="ident">Gadget</span>{<span class="ident">id</span>: <span class="number">1</span>, <span class="ident">owner</span>: <span class="ident">gadget_owner</span>.<span class="ident">clone</span>()});
    <span class="kw">let</span> <span class="ident">gadget2</span> <span class="op">=</span> <span class="ident">Rc::new</span>(<span class="ident">Gadget</span>{<span class="ident">id</span>: <span class="number">2</span>, <span class="ident">owner</span>: <span class="ident">gadget_owner</span>.<span class="ident">clone</span>()});

    <span class="comment">// Add the Gadgets to their Owner. To do this we mutably borrow from</span>
    <span class="comment">// the RefCell holding the Owner&#39;s Gadgets.</span>
    <span class="ident">gadget_owner</span>.<span class="ident">gadgets</span>.<span class="ident">borrow_mut</span>().<span class="ident">push</span>(<span class="ident">gadget1</span>.<span class="ident">clone</span>().<span class="ident">downgrade</span>());
    <span class="ident">gadget_owner</span>.<span class="ident">gadgets</span>.<span class="ident">borrow_mut</span>().<span class="ident">push</span>(<span class="ident">gadget2</span>.<span class="ident">clone</span>().<span class="ident">downgrade</span>());

    <span class="comment">// Iterate over our Gadgets, printing their details out</span>
    <span class="kw">for</span> <span class="ident">gadget_opt</span> <span class="kw">in</span> <span class="ident">gadget_owner</span>.<span class="ident">gadgets</span>.<span class="ident">borrow</span>().<span class="ident">iter</span>() {

        <span class="comment">// gadget_opt is a Weak&lt;Gadget&gt;. Since weak pointers can&#39;t guarantee</span>
        <span class="comment">// that their object is still allocated, we need to call upgrade()</span>
        <span class="comment">// on them to turn them into a strong reference. This returns an</span>
        <span class="comment">// Option, which contains a reference to our object if it still</span>
        <span class="comment">// exists.</span>
        <span class="kw">let</span> <span class="ident">gadget</span> <span class="op">=</span> <span class="ident">gadget_opt</span>.<span class="ident">upgrade</span>().<span class="ident">unwrap</span>();
        <span class="macro">println!</span>(<span class="string">&quot;Gadget {} owned by {}&quot;</span>, <span class="ident">gadget</span>.<span class="ident">id</span>, <span class="ident">gadget</span>.<span class="ident">owner</span>.<span class="ident">name</span>);
    }

    <span class="comment">// At the end of the method, gadget_owner, gadget1 and gadget2 get</span>
    <span class="comment">// destroyed. There are now no strong (`Rc&lt;T&gt;`) references to the gadgets.</span>
    <span class="comment">// Once they get destroyed, the Gadgets get destroyed. This zeroes the</span>
    <span class="comment">// reference count on Gadget Man, they get destroyed as well.</span>
}</pre></div>
</div><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<table><tr class="module-item"><td><a class="struct" href="struct.Rc.html" title="rc::Rc struct">Rc</a></td><td class="docblock-short"><p>A reference-counted pointer type over an immutable value.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Weak.html" title="rc::Weak struct">Weak</a></td><td class="docblock-short"><p>A weak version of <code>Rc&lt;T&gt;</code>.</p>
</td></tr></table><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2>
<table><tr class="module-item"><td><a class="fn" href="fn.get_mut.html" title="rc::get_mut fn">get_mut</a></td><td class="docblock-short"><p>Returns a mutable reference to the contained value if the <code>Rc&lt;T&gt;</code> is unique.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.is_unique.html" title="rc::is_unique fn">is_unique</a></td><td class="docblock-short"><p>Returns true if there are no other <code>Rc</code> or <code>Weak&lt;T&gt;</code> values that share the
same inner value.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.strong_count.html" title="rc::strong_count fn">strong_count</a></td><td class="docblock-short"><p>Get the number of strong references to this value.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.try_unwrap.html" title="rc::try_unwrap fn">try_unwrap</a></td><td class="docblock-short"><p>Unwraps the contained value if the <code>Rc&lt;T&gt;</code> is unique.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.weak_count.html" title="rc::weak_count fn">weak_count</a></td><td class="docblock-short"><p>Get the number of weak references to this value.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="rc" data-search-index-js="../search-index.js" data-search-js="../search.js"></div>
    <script src="../main.js"></script></body></html>